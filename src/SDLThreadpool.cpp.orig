#include "SDLThreadpool.h"

SDLThreadpool::SDLThreadpool()
{
<<<<<<< HEAD
    maxThreads = SDL_GetCPUCount();
    pool = new SDL_Thread*[maxThreads];

    for(int i = 0; i < maxThreads; ++i)
    {
        char name[32];
        sprintf(name,"pool%d", i);
        SDL_CreateThread(poolFunc, name, this);
    }
=======
    available = SDL_CreateCond();
>>>>>>> 39b907af4ea4367096692f4fcfce09dad1223db9
}

SDLThreadpool::~SDLThreadpool()
{
<<<<<<< HEAD

=======
    SDL_DestroyCond(available);
>>>>>>> 39b907af4ea4367096692f4fcfce09dad1223db9
}

void SDLThreadpool::addJob(Updateable* job)
{
    queue.push(job);
}

void SDLThreadpool::closePool(void)
{
<<<<<<< HEAD
    Event* death[maxThreads];

    for(int i = 0; i < maxThreads; ++i)
    {
        death[i] = new Event();
        queue.push(new Poison(death[i]));
    }

    for(int i = 0; i < maxThreads; ++i)
    {
        death[i]->wait();
    }
}

int SDLThreadpool::poolFunc(void* thisPointer)
{
    SDLThreadpool* tp = (SDLThreadpool*) thisPointer;
    tp->process();

    return 0;
}

void SDLThreadpool::process(void)
{
    while(status != Stop)
    {
        Updateable* job = queue.pop();
        job->update();
    }
}
=======
    // Do something!
}
>>>>>>> 39b907af4ea4367096692f4fcfce09dad1223db9
